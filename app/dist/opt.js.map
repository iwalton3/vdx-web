{"version":3,"sources":["opt.js"],"sourcesContent":["/**\n * opt() - Source Mangling for Fine-Grained Reactivity\n *\n * Transforms template functions to wrap all ${EXPR} expressions in\n * html.contain(() => (EXPR)), enabling Solid-style fine-grained reactivity.\n *\n * Usage:\n *   template: eval(opt(() => html`<div>${this.state.count}</div>`))\n *\n * The eval() runs in the user's module scope, giving access to all imports.\n * This is similar to how Solid requires certain patterns for its compiler.\n */\n\n/**\n * Main optimization function.\n * Takes a template function and returns a string of mangled source code.\n * User must wrap in eval() to get the actual function.\n *\n * @param {Function} templateFn - The template function to optimize\n * @returns {string} Mangled source code string (wrap in eval())\n *\n * @example\n * // Simple case\n * template: eval(opt(() => html`<div>${this.state.count}</div>`))\n *\n * // With external imports - eval gives access automatically\n * import { formatDate } from './utils.js';\n * template: eval(opt(() => html`<div>${formatDate(this.state.date)}</div>`))\n */\nexport function opt(templateFn) {\n    const source = templateFn.toString();\n    const converted = convertArrowToFunction(source);\n    const mangled = mangleTemplateSource(converted);\n\n    // Return string for user to eval in their module scope\n    return '(' + mangled + ')';\n}\n\n/**\n * Convert arrow functions to regular functions for proper `this` binding.\n * Arrow functions lexically bind `this`, which breaks component context.\n *\n * Handles:\n *   () => { body }     ->  function() { body }\n *   () => expr         ->  function() { return expr; }\n *\n * @param {string} source - Function source code\n * @returns {string} Converted source with regular function syntax\n */\nfunction convertArrowToFunction(source) {\n    const trimmed = source.trim();\n\n    // () => { body }  ->  function() { body }\n    if (/^\\(\\s*\\)\\s*=>\\s*\\{/.test(trimmed)) {\n        return trimmed.replace(/^\\(\\s*\\)\\s*=>\\s*\\{/, 'function() {');\n    }\n\n    // () => expr  ->  function() { return expr; }\n    if (/^\\(\\s*\\)\\s*=>\\s*/.test(trimmed)) {\n        const expr = trimmed.replace(/^\\(\\s*\\)\\s*=>\\s*/, '');\n        return 'function() { return ' + expr + '; }';\n    }\n\n    return source;  // Already a regular function\n}\n\n/**\n * Extract all ${...} expressions from html`` template literals only.\n * Skips expressions in regular template literals like `step-${n}`.\n *\n * Properly handles:\n *   - Nested braces: ${items.map(x => x.name)}\n *   - Nested templates: ${items.map(x => `${x.name}`)}\n *   - Object literals: ${{ a: 1 }}\n *   - String literals: ${msg || \"default\"}\n *\n * @param {string} source - Template source code\n * @returns {Array<{start: number, end: number, expr: string}>} Expression locations\n */\nfunction extractExpressions(source, debug = false) {\n    const expressions = [];\n    let i = 0;\n\n    // Find all html`` templates and extract expressions only from those\n    while (i < source.length) {\n        // Look for html` (the start of an html tagged template)\n        if (source.slice(i, i + 4) === 'html' && source[i + 4] === '`') {\n            i += 5;  // Skip past 'html`'\n\n            // Now we're inside an html template - find expressions until closing `\n            // But we need to handle nested templates within expressions\n            let templateDepth = 1;  // We're already inside one html template\n            let inString = false;\n            let stringChar = null;\n\n            while (i < source.length && templateDepth > 0) {\n                const ch = source[i];\n                const prev = i > 0 ? source[i - 1] : '';\n\n                // Handle escape sequences\n                if (prev === '\\\\' && !isEscaped(source, i - 1)) {\n                    i++;\n                    continue;\n                }\n\n                // Handle strings in expressions (not inside template literal text)\n                if (templateDepth === 1 && !inString && (ch === '\"' || ch === \"'\")) {\n                    // Only track strings when we're at expression level, not template text\n                    // Actually, we're inside the template text here, not expressions\n                    // Skip this\n                }\n\n                // Handle closing backtick - end of template\n                if (ch === '`' && !inString) {\n                    templateDepth--;\n                    if (templateDepth === 0) {\n                        i++;\n                        break;\n                    }\n                    i++;\n                    continue;\n                }\n\n                // Handle ${ - start of expression\n                if (ch === '$' && source[i + 1] === '{' && !inString) {\n                    const start = i;\n                    i += 2;\n\n                    // Parse the expression, handling nesting\n                    const expr = parseExpression(source, i);\n                    i = expr.end;\n\n                    if (debug) {\n                        console.log(`Expression: start=${start}, end=${i}, expr=\"${expr.text.slice(0, 60)}...\"`);\n                    }\n\n                    expressions.push({\n                        start,\n                        end: i,\n                        expr: expr.text\n                    });\n                    continue;\n                }\n\n                i++;\n            }\n        } else {\n            i++;\n        }\n    }\n\n    return expressions;\n}\n\n/**\n * Parse a single expression starting at position i (after the ${).\n * Returns the expression text and end position (after the closing }).\n */\nfunction parseExpression(source, startPos) {\n    let i = startPos;\n    let depth = 1;  // We're inside ${ so depth starts at 1\n    let inString = false;\n    let stringChar = null;\n    let inTemplate = false;  // Track if we're inside a nested template literal\n\n    while (i < source.length && depth > 0) {\n        const ch = source[i];\n        const prev = i > 0 ? source[i - 1] : '';\n\n        // Handle escape sequences\n        if (prev === '\\\\' && !isEscaped(source, i - 1)) {\n            i++;\n            continue;\n        }\n\n        // Handle comments (only when not in string or template)\n        if (!inString && !inTemplate) {\n            // Single-line comment\n            if (ch === '/' && source[i + 1] === '/') {\n                while (i < source.length && source[i] !== '\\n') {\n                    i++;\n                }\n                continue;\n            }\n            // Multi-line comment\n            if (ch === '/' && source[i + 1] === '*') {\n                i += 2;\n                while (i < source.length - 1 && !(source[i] === '*' && source[i + 1] === '/')) {\n                    i++;\n                }\n                i += 2;\n                continue;\n            }\n        }\n\n        // Handle strings\n        if (!inString && !inTemplate && (ch === '\"' || ch === \"'\")) {\n            inString = true;\n            stringChar = ch;\n            i++;\n            continue;\n        }\n        if (inString && ch === stringChar && !isEscaped(source, i)) {\n            inString = false;\n            stringChar = null;\n            i++;\n            continue;\n        }\n        if (inString) {\n            i++;\n            continue;\n        }\n\n        // Handle nested template literals (not html``, just regular ``)\n        if (ch === '`' && !inTemplate) {\n            inTemplate = true;\n            i++;\n            continue;\n        }\n        if (ch === '`' && inTemplate) {\n            inTemplate = false;\n            i++;\n            continue;\n        }\n\n        // Handle ${ inside nested template - need to parse recursively\n        if (inTemplate && ch === '$' && source[i + 1] === '{') {\n            i += 2;\n            const nested = parseExpression(source, i);\n            i = nested.end;\n            continue;\n        }\n\n        // Handle braces (when not in template)\n        if (!inTemplate && ch === '{') {\n            depth++;\n            i++;\n            continue;\n        }\n        if (!inTemplate && ch === '}') {\n            depth--;\n            if (depth === 0) {\n                // Found the closing brace\n                const text = source.slice(startPos, i);\n                return { text, end: i + 1 };\n            }\n            i++;\n            continue;\n        }\n\n        i++;\n    }\n\n    // If we get here, the expression wasn't properly closed\n    const text = source.slice(startPos, i);\n    return { text, end: i };\n}\n\n// Add a debug version we can call from browser\nexport function extractExpressionsDebug(source) {\n    return extractExpressions(source, true);\n}\n\n/**\n * Check if character at position is escaped (odd number of preceding backslashes)\n */\nfunction isEscaped(source, pos) {\n    let count = 0;\n    let p = pos - 1;\n    while (p >= 0 && source[p] === '\\\\') {\n        count++;\n        p--;\n    }\n    return count % 2 === 1;\n}\n\n/**\n * Determine if an expression should be skipped (not wrapped in html.contain).\n *\n * Skip:\n *   - contain(...) - already isolated\n *   - raw(...) - no reactivity needed\n *   - Arrow functions - already functions\n *   - Function expressions - already functions\n *   - html.contain(...) - already wrapped\n *\n * @param {string} expr - The expression to check\n * @returns {boolean} True if should skip wrapping\n */\nfunction shouldSkipWrapping(expr) {\n    const trimmed = expr.trim();\n\n    // Skip already-isolated helpers and special vnodes\n    // - contain/raw: already isolated\n    // - memoEach: has its own caching mechanism, complex to wrap in contain\n    // - when/each: condition/array is evaluated before callback runs, captured vars won't update\n    if (/^(contain|raw|html\\.contain|memoEach|when|each)\\s*\\(/.test(trimmed)) {\n        return true;\n    }\n\n    // Skip expressions containing raw() anywhere - raw() returns a special vnode\n    // marker that must be placed directly in the template, not wrapped\n    if (/\\braw\\s*\\(/.test(trimmed)) {\n        return true;\n    }\n\n    // Skip arrow functions: () => ..., x => ..., (a, b) => ...\n    if (/^\\([^)]*\\)\\s*=>/.test(trimmed) || /^\\w+\\s*=>/.test(trimmed)) {\n        return true;\n    }\n\n    // Skip function expressions\n    if (/^function\\s*[\\w]*\\s*\\(/.test(trimmed)) {\n        return true;\n    }\n\n    // Skip async arrow functions\n    if (/^async\\s+\\([^)]*\\)\\s*=>/.test(trimmed) || /^async\\s+\\w+\\s*=>/.test(trimmed)) {\n        return true;\n    }\n\n    // Skip async function expressions\n    if (/^async\\s+function\\s*[\\w]*\\s*\\(/.test(trimmed)) {\n        return true;\n    }\n\n    // Skip slot/children access - these are already DOM nodes/vnodes\n    // and don't need reactive wrapping\n    // Matches: this.props.children, this.props.slots.*, this.props.slots['name'], etc.\n    if (/^this\\.props\\.(children|slots)\\b/.test(trimmed)) {\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Mangle template source by wrapping expressions in html.contain().\n * Processes from end to start so indices don't shift.\n *\n * @param {string} source - Function source code\n * @returns {string} Mangled source with wrapped expressions\n */\nfunction mangleTemplateSource(source) {\n    const expressions = extractExpressions(source);\n\n    // Build new source, replacing expressions from end to start\n    // (so indices don't shift)\n    let result = source;\n    for (let i = expressions.length - 1; i >= 0; i--) {\n        const { start, end, expr } = expressions[i];\n\n        // Check if should skip wrapping\n        if (shouldSkipWrapping(expr)) {\n            continue;\n        }\n\n        // Replace ${expr} with ${html.contain(() => (expr))}\n        const wrapped = '${html.contain(() => (' + expr + '))}';\n        result = result.slice(0, start) + wrapped + result.slice(end);\n    }\n\n    return result;\n}\n\n// Export helpers for testing\nexport { convertArrowToFunction, extractExpressions, shouldSkipWrapping, mangleTemplateSource };\n"],"names":["export","function","opt","templateFn","const","source","toString","converted","convertArrowToFunction","mangled","mangleTemplateSource","return","trimmed","trim","if","test","replace","expr","extractExpressions","debug","false","expressions","let","i","while","length","slice","templateDepth","inString","stringChar","null","ch","prev","isEscaped","continue","break","start","parseExpression","end","console","log","push","text","else","startPos","depth","inTemplate","true","nested","extractExpressionsDebug","pos","count","p","shouldSkipWrapping","result","for","wrapped"],"mappings":"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","file":"opt.js"}