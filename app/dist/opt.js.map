{"version":3,"sources":["opt.js"],"sourcesContent":["/**\n * opt() - Source Mangling for Fine-Grained Reactivity\n *\n * Transforms template functions to wrap all ${EXPR} expressions in\n * html.contain(() => (EXPR)), enabling Solid-style fine-grained reactivity.\n *\n * Usage:\n *   template: eval(opt(() => html`<div>${this.state.count}</div>`))\n *\n * The eval() runs in the user's module scope, giving access to all imports.\n * This is similar to how Solid requires certain patterns for its compiler.\n */\n\n/**\n * Main optimization function.\n * Takes a template function and returns a string of mangled source code.\n * User must wrap in eval() to get the actual function.\n *\n * @param {Function} templateFn - The template function to optimize\n * @returns {string} Mangled source code string (wrap in eval())\n *\n * @example\n * // Simple case\n * template: eval(opt(() => html`<div>${this.state.count}</div>`))\n *\n * // With external imports - eval gives access automatically\n * import { formatDate } from './utils.js';\n * template: eval(opt(() => html`<div>${formatDate(this.state.date)}</div>`))\n */\nexport function opt(templateFn) {\n    const source = templateFn.toString();\n    const converted = convertArrowToFunction(source);\n    const mangled = mangleTemplateSource(converted);\n\n    // Return string for user to eval in their module scope\n    return '(' + mangled + ')';\n}\n\n/**\n * Convert arrow functions to regular functions for proper `this` binding.\n * Arrow functions lexically bind `this`, which breaks component context.\n *\n * Handles:\n *   () => { body }     ->  function() { body }\n *   () => expr         ->  function() { return expr; }\n *\n * @param {string} source - Function source code\n * @returns {string} Converted source with regular function syntax\n */\nfunction convertArrowToFunction(source) {\n    const trimmed = source.trim();\n\n    // () => { body }  ->  function() { body }\n    if (/^\\(\\s*\\)\\s*=>\\s*\\{/.test(trimmed)) {\n        return trimmed.replace(/^\\(\\s*\\)\\s*=>\\s*\\{/, 'function() {');\n    }\n\n    // () => expr  ->  function() { return expr; }\n    if (/^\\(\\s*\\)\\s*=>\\s*/.test(trimmed)) {\n        const expr = trimmed.replace(/^\\(\\s*\\)\\s*=>\\s*/, '');\n        return 'function() { return ' + expr + '; }';\n    }\n\n    return source;  // Already a regular function\n}\n\n/**\n * Extract all ${...} expressions from html`` template literals only.\n * Skips expressions in regular template literals like `step-${n}`.\n *\n * Properly handles:\n *   - Nested braces: ${items.map(x => x.name)}\n *   - Nested templates: ${items.map(x => `${x.name}`)}\n *   - Object literals: ${{ a: 1 }}\n *   - String literals: ${msg || \"default\"}\n *\n * @param {string} source - Template source code\n * @returns {Array<{start: number, end: number, expr: string}>} Expression locations\n */\nfunction extractExpressions(source, debug = false) {\n    const expressions = [];\n    let i = 0;\n\n    // Find all html`` templates and extract expressions only from those\n    while (i < source.length) {\n        // Look for html`(the start of an html tagged template) if (source.slice(i, i + 4) === 'html' && source[i + 4] === '`') {\n            i += 5;  // Skip past 'html`' // Now we're inside an html template - find expressions until closing`\n            // But we need to handle nested templates within expressions\n            let templateDepth = 1;  // We're already inside one html template\n            let inString = false;\n            let stringChar = null;\n\n            while (i < source.length && templateDepth > 0) {\n                const ch = source[i];\n                const prev = i > 0 ? source[i - 1] : '';\n\n                // Handle escape sequences\n                if (prev === '\\\\' && !isEscaped(source, i - 1)) {\n                    i++;\n                    continue;\n                }\n\n                // Handle strings in expressions (not inside template literal text)\n                if (templateDepth === 1 && !inString && (ch === '\"' || ch === \"'\")) {\n                    // Only track strings when we're at expression level, not template text\n                    // Actually, we're inside the template text here, not expressions\n                    // Skip this\n                }\n\n                // Handle closing backtick - end of template\n                if (ch === '`' && !inString) {\n                    templateDepth--;\n                    if (templateDepth === 0) {\n                        i++;\n                        break;\n                    }\n                    i++;\n                    continue;\n                }\n\n                // Handle ${ - start of expression\n                if (ch === '$' && source[i + 1] === '{' && !inString) {\n                    const start = i;\n                    i += 2;\n\n                    // Parse the expression, handling nesting\n                    const expr = parseExpression(source, i);\n                    i = expr.end;\n\n                    if (debug) {\n                        console.log(`Expression: start=${start}, end=${i}, expr=\"${expr.text.slice(0, 60)}...\"`);\n                    }\n\n                    expressions.push({\n                        start,\n                        end: i,\n                        expr: expr.text\n                    });\n                    continue;\n                }\n\n                i++;\n            }\n        } else {\n            i++;\n        }\n    }\n\n    return expressions;\n}\n\n/**\n * Parse a single expression starting at position i (after the ${).\n * Returns the expression text and end position (after the closing }).\n */\nfunction parseExpression(source, startPos) {\n    let i = startPos;\n    let depth = 1;  // We're inside ${ so depth starts at 1\n    let inString = false;\n    let stringChar = null;\n    let inTemplate = false;  // Track if we're inside a nested template literal\n\n    while (i < source.length && depth > 0) {\n        const ch = source[i];\n        const prev = i > 0 ? source[i - 1] : '';\n\n        // Handle escape sequences\n        if (prev === '\\\\' && !isEscaped(source, i - 1)) {\n            i++;\n            continue;\n        }\n\n        // Handle comments (only when not in string or template)\n        if (!inString && !inTemplate) {\n            // Single-line comment\n            if (ch === '/' && source[i + 1] === '/') {\n                while (i < source.length && source[i] !== '\\n') {\n                    i++;\n                }\n                continue;\n            }\n            // Multi-line comment\n            if (ch === '/' && source[i + 1] === '*') {\n                i += 2;\n                while (i < source.length - 1 && !(source[i] === '*' && source[i + 1] === '/')) {\n                    i++;\n                }\n                i += 2;\n                continue;\n            }\n        }\n\n        // Handle strings\n        if (!inString && !inTemplate && (ch === '\"' || ch === \"'\")) {\n            inString = true;\n            stringChar = ch;\n            i++;\n            continue;\n        }\n        if (inString && ch === stringChar && !isEscaped(source, i)) {\n            inString = false;\n            stringChar = null;\n            i++;\n            continue;\n        }\n        if (inString) {\n            i++;\n            continue;\n        }\n\n        // Handle nested template literals (not html``, just regular ``)\n        if (ch === '`' && !inTemplate) {\n            inTemplate = true;\n            i++;\n            continue;\n        }\n        if (ch === '`' && inTemplate) {\n            inTemplate = false;\n            i++;\n            continue;\n        }\n\n        // Handle ${ inside nested template - need to parse recursively\n        if (inTemplate && ch === '$' && source[i + 1] === '{') {\n            i += 2;\n            const nested = parseExpression(source, i);\n            i = nested.end;\n            continue;\n        }\n\n        // Handle braces (when not in template)\n        if (!inTemplate && ch === '{') {\n            depth++;\n            i++;\n            continue;\n        }\n        if (!inTemplate && ch === '}') {\n            depth--;\n            if (depth === 0) {\n                // Found the closing brace\n                const text = source.slice(startPos, i);\n                return { text, end: i + 1 };\n            }\n            i++;\n            continue;\n        }\n\n        i++;\n    }\n\n    // If we get here, the expression wasn't properly closed\n    const text = source.slice(startPos, i);\n    return { text, end: i };\n}\n\n// Add a debug version we can call from browser\nexport function extractExpressionsDebug(source) {\n    return extractExpressions(source, true);\n}\n\n/**\n * Check if character at position is escaped (odd number of preceding backslashes)\n */\nfunction isEscaped(source, pos) {\n    let count = 0;\n    let p = pos - 1;\n    while (p >= 0 && source[p] === '\\\\') {\n        count++;\n        p--;\n    }\n    return count % 2 === 1;\n}\n\n/**\n * Determine if an expression should be skipped (not wrapped in html.contain).\n *\n * Skip:\n *   - contain(...) - already isolated\n *   - raw(...) - no reactivity needed\n *   - Arrow functions - already functions\n *   - Function expressions - already functions\n *   - html.contain(...) - already wrapped\n *\n * @param {string} expr - The expression to check\n * @returns {boolean} True if should skip wrapping\n */\nfunction shouldSkipWrapping(expr) {\n    const trimmed = expr.trim();\n\n    // Skip already-isolated helpers and template helpers\n    // when/each/memoEach are handled by the renderer and wrapping them breaks\n    // reactivity when their conditions use local variables\n    if (/^(contain|raw|html\\.contain|when|each|memoEach)\\s*\\(/.test(trimmed)) {\n        return true;\n    }\n\n    // Skip expressions containing raw() anywhere - raw() returns a special vnode\n    // marker that must be placed directly in the template, not wrapped\n    if (/\\braw\\s*\\(/.test(trimmed)) {\n        return true;\n    }\n\n    // Skip arrow functions: () => ..., x => ..., (a, b) => ...\n    if (/^\\([^)]*\\)\\s*=>/.test(trimmed) || /^\\w+\\s*=>/.test(trimmed)) {\n        return true;\n    }\n\n    // Skip function expressions\n    if (/^function\\s*[\\w]*\\s*\\(/.test(trimmed)) {\n        return true;\n    }\n\n    // Skip async arrow functions\n    if (/^async\\s+\\([^)]*\\)\\s*=>/.test(trimmed) || /^async\\s+\\w+\\s*=>/.test(trimmed)) {\n        return true;\n    }\n\n    // Skip async function expressions\n    if (/^async\\s+function\\s*[\\w]*\\s*\\(/.test(trimmed)) {\n        return true;\n    }\n\n    // Skip slot/children access - these are already DOM nodes/vnodes\n    // and don't need reactive wrapping\n    // Matches: this.props.children, this.props.slots.*, this.props.slots['name'], etc.\n    if (/^this\\.props\\.(children|slots)\\b/.test(trimmed)) {\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Mangle template source by wrapping expressions in html.contain().\n * Processes from end to start so indices don't shift.\n *\n * @param {string} source - Function source code\n * @returns {string} Mangled source with wrapped expressions\n */\nfunction mangleTemplateSource(source) {\n    const expressions = extractExpressions(source);\n\n    // Build new source, replacing expressions from end to start\n    // (so indices don't shift)\n    let result = source;\n    for (let i = expressions.length - 1; i >= 0; i--) {\n        const { start, end, expr } = expressions[i];\n\n        // Check if should skip wrapping\n        if (shouldSkipWrapping(expr)) {\n            continue;\n        }\n\n        // Replace ${expr} with ${html.contain(() => (expr))}\n        const wrapped = '${html.contain(() => (' + expr + '))}';\n        result = result.slice(0, start) + wrapped + result.slice(end);\n    }\n\n    return result;\n}\n\n// Export helpers for testing\nexport { convertArrowToFunction, extractExpressions, shouldSkipWrapping, mangleTemplateSource };\n"],"names":[],"mappings":"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","file":"opt.js"}