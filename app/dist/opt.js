export function opt(templateFn){const source=templateFn.toString();const converted=convertArrowToFunction(source);const mangled=mangleTemplateSource(converted);return'('+mangled+')';}function convertArrowToFunction(source){const trimmed=source.trim();if (/^\(\s*\)\s*=>\s*\{/.test(trimmed)){return trimmed.replace(/^\(\s*\)\s*=>\s*\{/,'function() {');}if (/^\(\s*\)\s*=>\s*/.test(trimmed)){const expr=trimmed.replace(/^\(\s*\)\s*=>\s*/,'');return'function() { return '+expr+'; }';}return source;}function extractExpressions(source,debug=false){const expressions=[];let i=0;while (i<source.length){i+=5;let templateDepth=1;let inString=false;let stringChar=null;while (i<source.length&&templateDepth>0){const ch=source[i];const prev=i>0?source[i-1]:'';if (prev==='\\'&&!isEscaped(source,i-1)){i++;continue;}if (templateDepth===1&&!inString&&(ch==='"'||ch==="'")){}if (ch==='`'&&!inString){templateDepth--;if (templateDepth===0){i++;break;}i++;continue;}if (ch==='$'&&source[i+1]==='{'&&!inString){const start=i;i+=2;const expr=parseExpression(source,i);i=expr.end;if (debug){console.log(`Expression: start=${start}, end=${i}, expr="${expr.text.slice(0,60)}..."`);}expressions.push({start,end:i,expr:expr.text});continue;}i++;}}else{i++;}}return expressions;}function parseExpression(source,startPos){let i=startPos;let depth=1;let inString=false;let stringChar=null;let inTemplate=false;while (i<source.length&&depth>0){const ch=source[i];const prev=i>0?source[i-1]:'';if (prev==='\\'&&!isEscaped(source,i-1)){i++;continue;}if (!inString&&!inTemplate){if (ch==='/'&&source[i+1]==='/'){while (i<source.length&&source[i]!=='\n'){i++;}continue;}if (ch==='/'&&source[i+1]==='*'){i+=2;while (i<source.length-1&&!(source[i]==='*'&&source[i+1]==='/')){i++;}i+=2;continue;}}if (!inString&&!inTemplate&&(ch==='"'||ch==="'")){inString=true;stringChar=ch;i++;continue;}if (inString&&ch===stringChar&&!isEscaped(source,i)){inString=false;stringChar=null;i++;continue;}if (inString){i++;continue;}if (ch==='`'&&!inTemplate){inTemplate=true;i++;continue;}if (ch==='`'&&inTemplate){inTemplate=false;i++;continue;}if (inTemplate&&ch==='$'&&source[i+1]==='{'){i+=2;const nested=parseExpression(source,i);i=nested.end;continue;}if (!inTemplate&&ch==='{'){depth++;i++;continue;}if (!inTemplate&&ch==='}'){depth--;if (depth===0){const text=source.slice(startPos,i);return{text,end:i+1};}i++;continue;}i++;}const text=source.slice(startPos,i);return{text,end:i};}export function extractExpressionsDebug(source){return extractExpressions(source,true);}function isEscaped(source,pos){let count=0;let p=pos-1;while (p>=0&&source[p]==='\\'){count++;p--;}return count%2===1;}function shouldSkipWrapping(expr){const trimmed=expr.trim();if (/^(contain|raw|html\.contain|memoEach)\s*\(/.test(trimmed)){return true;}if (/\braw\s*\(/.test(trimmed)){return true;}if (/^\([^)]*\)\s*=>/.test(trimmed)||/^\w+\s*=>/.test(trimmed)){return true;}if (/^function\s*[\w]*\s*\(/.test(trimmed)){return true;}if (/^async\s+\([^)]*\)\s*=>/.test(trimmed)||/^async\s+\w+\s*=>/.test(trimmed)){return true;}if (/^async\s+function\s*[\w]*\s*\(/.test(trimmed)){return true;}if (/^this\.props\.(children|slots)\b/.test(trimmed)){return true;}return false;}function mangleTemplateSource(source){const expressions=extractExpressions(source);let result=source;for (let i=expressions.length-1;i>=0;i--){const{start,end,expr}=expressions[i];if (shouldSkipWrapping(expr)){continue;}const wrapped='${html.contain(() => ('+expr+'))}';result=result.slice(0,start)+wrapped+result.slice(end);}return result;}export{convertArrowToFunction,extractExpressions,shouldSkipWrapping,mangleTemplateSource};
//# sourceMappingURL=opt.js.map
